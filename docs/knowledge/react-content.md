# Guidelines: Using Markdown Content in a Next.js (React + TypeScript) Website

*Audience:* Next.js developers who want a boringly reliable (and pleasantly scalable) way to author site content in separate `.md` files—without painting themselves into an architectural corner.

*Covers:* Folder layout, frontmatter conventions, typing with Zod, MD vs. MDX choices, rendering pipelines (remark/rehype vs. MDX), App Router patterns, SEO/metadata, i18n, images, links, build & CI, and migration notes.

---

## 0) TL;DR Decision Matrix

| Need                                                                        | Pick                                      | Why                                              |
| --------------------------------------------------------------------------- | ----------------------------------------- | ------------------------------------------------ |
| **Pure Markdown pages** (no React in content), fast build, **minimal deps** | **Markdown + remark/rehype**              | Simple, fast, type-safe frontmatter via Zod      |
| Markdown with occasional React components inside content                    | MDX (next-mdx-remote or Contentlayer MDX) | Content authors get power toys; slightly heavier |
| Many content types, strong typing, content search/graph                     | Contentlayer                              | Autogenerated types + nice dev ergonomics        |

> Start here if you want the simplest possible pipeline.

---

## 0.1) Preset A — Pure Markdown (Minimal Deps) **Copy/Paste Setup**

### Install (pnpm shown; use npm/yarn if you like)

```bash
pnpm add gray-matter unified remark-parse remark-gfm remark-rehype rehype-slug rehype-autolink-headings rehype-stringify zod
```

### Add files

* `lib/content/schema.ts` — Zod schema (already in doc; unchanged)
* `lib/content/fs.ts` — FS helpers (already in doc; unchanged)
* `lib/content/markdown.ts` — remark/rehype pipeline (already in doc; unchanged)
* `lib/content/index.ts` — list/get content (already in doc; unchanged)
* `app/(site)/blog/[slug]/page.tsx` and `app/(site)/blog/page.tsx` — routes (already in doc; unchanged)

### Content directory

```
/content
  /blog
    2025-10-23-hello-world.md
  /docs
    getting-started.md
```

### Example `.md`

```md
---
title: "Hello, World"
description: "First post using pure Markdown in Next.js"
slug: hello-world
published: true
publishedAt: 2025-10-23
author: "Site Team"
tags: ["intro"]
lang: "en"
---

# Hello, World

This page is authored in **Markdown**. Tables, code blocks, and GFM features are supported.

| Feature | Works? |
|---|---|
| GFM Tables | ✅ |
| Autolinked headings | ✅ |
```

### Next.js specifics

* Uses **App Router** with `generateStaticParams` for SSG.
* **No MDX**: no React inside content, no MDX bundling cost.
* Security: raw HTML stays disabled; if you *must* allow HTML, add `rehype-sanitize` (not installed by default to keep deps minimal).

### Optional (still minimal)

* Incremental static regeneration: if you want ISR, add `revalidate` to the page (e.g., `export const revalidate = 3600`).
* Search: build a tiny index at build-time from `listContent()` and ship JSON.

---

|---|---|
| Pure Markdown pages (no React in content), fast build, minimal deps | **Markdown + remark/rehype** | Simple, fast, type-safe frontmatter via Zod |
| Markdown with occasional React components inside content | **MDX (next-mdx-remote or Contentlayer MDX)** | Content authors get power toys; slightly heavier |
| Many content types, strong typing, content search/graph | **Contentlayer** | Autogenerated types + nice dev ergonomics |

> Rule of thumb: start with plain Markdown. If you catch yourself copy-pasting JSX into `.md`, graduate to MDX.

---

## 1) Project Structure

```
root
├─ app/                           # Next.js App Router
│  ├─ (site)/
│  │  ├─ blog/                    # Route segment for blog
│  │  │  ├─ [slug]/page.tsx
│  │  │  └─ page.tsx              # list page
│  │  └─ docs/                    # Route segment for docs
│  └─ layout.tsx
│  └─ globals.css
├─ content/
│  ├─ blog/
│  │  ├─ 2025-10-01-hello-world.md
│  │  └─ 2025-10-19-nextjs-markdown-guide.md
│  └─ docs/
│     ├─ getting-started.md
│     └─ architecture/overview.md
├─ lib/
│  ├─ content/
│  │  ├─ schema.ts                # Zod schemas for frontmatter
│  │  ├─ fs.ts                    # file system helpers
│  │  ├─ markdown.ts              # remark/rehype pipeline
│  │  └─ index.ts                 # list/get helpers
├─ public/
│  └─ images/
├─ scripts/
│  └─ new-content.ts              # scaffolds new posts
├─ package.json
└─ tsconfig.json
```

---

## 2) Frontmatter Conventions (Typed)

**Goals**: Consistency across content types, SEO-ready, future-proof for i18n and series/collections.

```yaml
---
title: "Next.js Markdown Content Guide"
description: "How to source Markdown files in a Next.js app (with TypeScript)."
slug: nextjs-markdown-content-guide
published: true
publishedAt: 2025-10-23
author: "Chris Nattress"
tags: ["nextjs", "markdown", "typescript"]
coverImage: "/images/markdown-guide-cover.png"
lang: "en"
# Optional extras:
series: "nextjs-content"
order: 10
canonicalUrl: "https://example.com/blog/nextjs-markdown-content-guide"
---
```

### Zod Schema (lib/content/schema.ts)

```ts
import { z } from "zod";

export const Frontmatter = z.object({
  title: z.string().min(1),
  description: z.string().min(1),
  slug: z.string().min(1),
  published: z.boolean().default(false),
  publishedAt: z.coerce.date().optional(),
  author: z.string().optional(),
  tags: z.array(z.string()).default([]),
  coverImage: z.string().optional(),
  lang: z.string().default("en"),
  series: z.string().optional(),
  order: z.number().optional(),
  canonicalUrl: z.string().url().optional(),
});
export type FrontmatterT = z.infer<typeof Frontmatter>;
```

> Tip: `z.coerce.date()` gives you a `Date` from string input. Future you says thanks.

---

## 3) Reading Markdown Files (FS Helpers)

`lib/content/fs.ts`

```ts
import fs from "node:fs/promises";
import path from "node:path";

export const CONTENT_DIR = path.join(process.cwd(), "content");

export async function readFileUtf8(p: string) {
  return fs.readFile(p, "utf8");
}

export function joinContentPath(...segments: string[]) {
  return path.join(CONTENT_DIR, ...segments);
}

export async function listMarkdownFiles(dir: string) {
  const full = joinContentPath(dir);
  const all = await fs.readdir(full, { withFileTypes: true });
  const files: string[] = [];
  for (const e of all) {
    const p = path.join(full, e.name);
    if (e.isDirectory()) {
      files.push(...(await listMarkdownFiles(path.join(dir, e.name))));
    } else if (e.isFile() && e.name.endsWith(".md")) {
      files.push(path.join(dir, e.name));
    }
  }
  return files;
}
```

---

## 4) Markdown Parsing Pipeline (remark/rehype)

`lib/content/markdown.ts`

```ts
import matter from "gray-matter";
import { Frontmatter } from "./schema";
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkGfm from "remark-gfm";
import remarkToc from "remark-toc";
import remarkRehype from "remark-rehype";
import rehypeSlug from "rehype-slug";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypeStringify from "rehype-stringify";

export type ParsedMarkdown = {
  html: string;
  data: ReturnType<typeof Frontmatter.parse>;
};

export async function parseMarkdown(raw: string): Promise<ParsedMarkdown> {
  const { content, data } = matter(raw);
  const fm = Frontmatter.parse(data);

  const file = await unified()
    .use(remarkParse)
    .use(remarkGfm)
    .use(remarkToc, { heading: "Table of contents", maxDepth: 3 })
    .use(remarkRehype)
    .use(rehypeSlug)
    .use(rehypeAutolinkHeadings, { behavior: "wrap" })
    .use(rehypeStringify)
    .process(content);

  return { html: String(file), data: fm };
}
```

---

## 5) Content Indexing Helpers

`lib/content/index.ts`

```ts
import path from "node:path";
import { readFileUtf8, joinContentPath, listMarkdownFiles } from "./fs";
import { parseMarkdown } from "./markdown";

export type ContentItem = {
  slug: string;
  html: string;
  data: ReturnType<typeof import("./schema").Frontmatter.parse>;
  filePath: string;
};

export async function getContentBySlug(baseDir: string, slug: string): Promise<ContentItem | null> {
  const mdPath = joinContentPath(baseDir, `${slug}.md`);
  try {
    const raw = await readFileUtf8(mdPath);
    const parsed = await parseMarkdown(raw);
    return { slug, html: parsed.html, data: parsed.data, filePath: mdPath };
  } catch {
    return null;
  }
}

export async function listContent(baseDir: string): Promise<ContentItem[]> {
  const files = await listMarkdownFiles(baseDir);
  const items: ContentItem[] = [];
  for (const file of files) {
    const raw = await readFileUtf8(joinContentPath(file));
    const parsed = await parseMarkdown(raw);
    const slug = path.basename(file, ".md");
    items.push({ slug, html: parsed.html, data: parsed.data, filePath: joinContentPath(file) });
  }
  return items
    .filter((i) => i.data.published)
    .sort((a, b) => (b.data.publishedAt?.getTime() ?? 0) - (a.data.publishedAt?.getTime() ?? 0));
}
```

---

## 6) App Router Integration (Rendering Markdown)

### Dynamic Route: `app/(site)/blog/[slug]/page.tsx`

```tsx
import { notFound } from "next/navigation";
import { getContentBySlug } from "@/lib/content";
import type { Metadata } from "next";

export async function generateStaticParams() {
  const { listContent } = await import("@/lib/content");
  const items = await listContent("blog");
  return items.map((i) => ({ slug: i.slug }));
}

export async function generateMetadata({ params }: { params: { slug: string } }): Promise<Metadata> {
  const item = await getContentBySlug("blog", params.slug);
  if (!item) return {};
  const { title, description, canonicalUrl, coverImage } = item.data;
  return {
    title,
    description,
    alternates: canonicalUrl ? { canonical: canonicalUrl } : undefined,
    openGraph: coverImage ? { images: [{ url: coverImage }] } : undefined,
  } satisfies Metadata;
}

export default async function BlogPostPage({ params }: { params: { slug: string } }) {
  const item = await getContentBySlug("blog", params.slug);
  if (!item) notFound();
  return (
    <article className="prose prose-neutral max-w-3xl mx-auto py-8">
      <h1>{item.data.title}</h1>
      {/* eslint-disable-next-line react/no-danger */}
      <div dangerouslySetInnerHTML={{ __html: item.html }} />
    </article>
  );
}
```

### Index Route: `app/(site)/blog/page.tsx`

```tsx
import Link from "next/link";
import { listContent } from "@/lib/content";

export default async function BlogIndexPage() {
  const posts = await listContent("blog");
  return (
    <div className="max-w-3xl mx-auto py-8">
      <h1 className="text-3xl font-semibold mb-6">Blog</h1>
      <ul className="space-y-4">
        {posts.map((p) => (
          <li key={p.slug}>
            <Link className="text-blue-600 underline" href={`/blog/${p.slug}`}>
              {p.data.title}
            </Link>
            <p className="text-sm text-neutral-600">{p.data.description}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

> **Security note:** we use `dangerouslySetInnerHTML` because we’re rendering HTML. The remark/rehype stack here does not allow raw HTML by default; keep it that way unless you trust authors. Consider `rehype-sanitize` if enabling raw HTML.

---

## 7) Authoring Conventions

* **File names**: kebab-case, prepend date for blog posts: `YYYY-MM-DD-title.md`.
* **One H1 per doc**: Title should also live in frontmatter; the H1 can repeat it for readability.
* **Links**: Use absolute paths (`/docs/…`) for internal links. Avoid hard-coded domains.
* **Images**: Place in `public/images/…`. Refer via `/images/...`. Prefer `next/image` in custom MDX components (see MDX section).
* **Headings**: H2–H3 structure; avoid jumping levels.
* **Tables**: Use GFM tables. We enable `remark-gfm`.
* **Tags**: Keep to 3–5 meaningful tags.

---

## 8) Upgrading to MDX (When You Need React in Content)

If you need React components inside content (callouts, alerts, sandboxes):

* Replace the pipeline with **MDX** using `next-mdx-remote` or Contentlayer’s MDX.
* Create an `mdx-components.tsx` map to render MDX elements with custom components (e.g., swap `img` → `next/image`).

**Minimal MDX sketch**

```ts
// lib/content/mdx.ts (sketch)
import matter from "gray-matter";
import { Frontmatter } from "./schema";
import { serialize } from "next-mdx-remote/serialize";

export async function parseMdx(raw: string) {
  const { content, data } = matter(raw);
  const fm = Frontmatter.parse(data);
  const mdxSource = await serialize(content, {
    mdxOptions: {
      remarkPlugins: [require("remark-gfm")],
      rehypePlugins: [require("rehype-slug"), require("rehype-autolink-headings")],
    },
  });
  return { mdxSource, data: fm };
}
```

Then render with `<MDXRemote {...mdxSource} components={mdxComponents} />`.

> **Tradeoffs:** MDX unlocks React in content but increases build time and cognitive load. Use surgically.

---

## 9) SEO & Metadata

* Populate `title`, `description`, `canonicalUrl`, and `coverImage` via frontmatter → Next.js `generateMetadata`.
* Add Open Graph images for shareability.
* Generate `sitemap.xml` and `robots.txt` (e.g., with `next-sitemap`) using the content index.

---

## 10) Internationalization (Optional)

* Add `lang` in frontmatter, e.g., `en`, `es`.
* Directory strategy: `content/{lang}/blog/...` or per-file frontmatter with language and translate variants.
* For translated pairs, link via `alternate` metadata and cross-reference.

---

## 11) Images in Markdown: Three Options

1. **Plain Markdown images**: `![alt](/images/foo.png)` — simple, no optimization.

2. **MDX + next/image**: create an MDX component mapping `img` → Next `<Image />`.

3. **rehype plugins** that transform images → beware of complexity; MDX is usually cleaner.

> Accessibility: always include meaningful alt text. If decorative, consider empty alt (`""`).

---

## 12) Internal Links & 404s

* Use absolute paths (`/docs/...`).
* Consider a link-check CI step (e.g., `npm run check:links`) that parses markdown and verifies internal links.
* Provide a friendly 404 page in `app/not-found.tsx`.

---

## 13) Build & CI

* **Type-check**: `tsc --noEmit` in CI.
* **Content lint**: optional markdownlint, remark-lint.
* **Broken links**: optional script.
* **Preview**: Deploy PR previews (e.g., Vercel/Netlify). Content-only PRs should be easy to review.

Example scripts in `package.json`:

```json
{
  "scripts": {
    "typecheck": "tsc --noEmit",
    "lint:md": "markdownlint '**/*.md' --ignore node_modules",
    "check:links": "node scripts/check-links.mjs"
  }
}
```

---

## 14) Content Scaffolding Script

`scripts/new-content.ts`

```ts
#!/usr/bin/env ts-node
import fs from "node:fs/promises";
import path from "node:path";

const type = process.argv[2] ?? "blog"; // blog|docs
const title = process.argv.slice(3).join(" ") || "Untitled";
const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
const date = new Date().toISOString().slice(0, 10);
const dir = path.join(process.cwd(), "content", type);

const template = `---\ntitle: "${title}"\ndescription: ""\nslug: ${slug}\npublished: false\npublishedAt: ${date}\nauthor: ""\ntags: []\nlang: "en"\n---\n\n# ${title}\n\nWrite something brilliant. Or at least ship it.\n`;

async function main() {
  await fs.mkdir(dir, { recursive: true });
  const file = path.join(dir, `${date}-${slug}.md`);
  await fs.writeFile(file, template, "utf8");
  console.log("Created:", file);
}

main();
```

> Usage: `pnpm ts-node scripts/new-content.ts blog "My New Post"`

---

## 15) Performance Notes

* Static generation via `generateStaticParams` keeps TTFB low.
* Avoid huge Markdown files (> 1–2 MB). Split long docs.
* Image dimensions: pre-size and compress.

---

## 16) Security & Sanitization

* Keep raw HTML disabled in remark unless you absolutely trust authors.
* If enabling raw HTML, add `rehype-sanitize` with a strict schema.
* Never render user-submitted Markdown with this pipeline without sanitization.

---

## 17) Content Versioning

* Store `/content` in the repo so content changes are PR-reviewed.
* For non-technical authors, pair with a simple Git-based CMS (e.g., Netlify CMS) that writes to `/content`.

---

## 18) Migration Tips (from pages/ router or older sites)

* Map old slugs to new with redirects in `next.config.js`.
* Keep canonical URLs in frontmatter for SEO continuity.
* Ensure 301s for moved content; verify in Search Console.

---

## 19) Testing (Yes, For Content)

* Render critical pages in Playwright to catch runtime MDX issues.
* Unit-test your `parseMarkdown` with representative samples (tables, code blocks, edge cases).

---

## 20) Optional: Contentlayer Setup Sketch

If your site grows:

* Define content types in `contentlayer.config.ts`.
* Get generated TS types for frontmatter/content.
* Query content via the generated `allPosts` arrays.

> Start simple; graduate if and when you feel the pain. (You’ll know.)

---

## 21) Dependencies Cheat Sheet

**Plain Markdown path**

* `gray-matter`, `unified`, `remark-parse`, `remark-gfm`, `remark-toc`, `remark-rehype`, `rehype-slug`, `rehype-autolink-headings`, `rehype-stringify`, `zod`

**MDX path**

* `next-mdx-remote`, `remark-gfm`, `rehype-slug`, `rehype-autolink-headings`, `zod`

---

## 22) Example README Snippet for Contributors

> Place Markdown in `/content/{blog|docs}`. Add frontmatter per the schema. Run `pnpm ts-node scripts/new-content.ts blog "Title"` to scaffold. Content is statically generated at build. Use headings sensibly, write clear alt text, and avoid putting React in Markdown unless we switch to MDX.

---

## 23) Final Notes

* Keep content and presentation decoupled. Markdown is the content; React is the renderer.
* Let types (Zod) do the nitpicky work so you don’t have to. (Future you is already writing a thank-you note.)
* When you need React inside content, switch to MDX deliberately, not accidentally.

Happy shipping! 🚀
